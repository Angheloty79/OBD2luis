'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var connection_1 = require('./connection');
var events_1 = require('events');
var parser_1 = require('./parser');
var Promise = require('bluebird');
var log_1 = require('./log');
/**
 * Constructor function to create a poller instance.
 *
 * Poller instances will request data from the ECU at a defined refresh rate.
 *
 * @param {Object} opts
 */
var ECUPoller = (function (_super) {
    __extends(ECUPoller, _super);
    function ECUPoller(args) {
        _super.call(this);
        this.msgSendCount = 0;
        this.msgRecvCount = 0;
        this.args = args;
        this.lastResponseTs = null;
        this.lastPollTs = null;
        this.polling = false;
        this.locked = false;
        this.log = log_1["default"](args.pid.getName());
        this.log('created poller for %s', args.pid.getName());
    }
    /**
     * We want to get as close to the requested refresh rate as possible.
     * This means if the ECU has a response delay then we account for it.
     *
     * @param  {Number} max         The max delay in between pools
     * @param  {Number} lastPollTs  The time we issued the last poll
     * @return {Number}
     */
    ECUPoller.prototype.getNextPollDelay = function () {
        if (this.lastPollTs) {
            // A poll has occurred previously. If we're calling this function
            // before the max interval time is reached then we must wait n ms
            // where n is the difference between the max poll rate and last poll sent
            var delta = this.lastResponseTs - this.lastPollTs;
            if (delta <= 0) {
                this.log("delta between lastResponseTs and lastPollTs for " + this.args.pid.getName() + " was " + delta + ". defaulting to interval of " + (this.args.interval || 1000));
                return this.args.interval || 1000;
            }
            var nextPoll = delta > this.args.interval ? 0 : this.args.interval - delta;
            this.log('getting poll time for %s, using last time of %s vs now %s. delta is %dms.', this.args.pid.getName(), new Date(this.lastPollTs).toISOString(), new Date().toISOString(), delta);
            this.log("next poll in " + nextPoll + "ms");
            return nextPoll;
        }
        else {
            // No previous poll has occurred yet so fire one right away
            return 0;
        }
    };
    /**
     * Locks this poller to prevent it sending any more messages to the ECU
     * @return {void}
     */
    ECUPoller.prototype.lock = function () {
        this.locked = true;
    };
    /**
     * Unlocks this poller to allow it to send more messages to the ECU
     * @return {void}
     */
    ECUPoller.prototype.unlock = function () {
        this.locked = false;
    };
    /**
     * Returns a boolean, where true indicates this instance is locked
     * @return {boolean}
     */
    ECUPoller.prototype.isLocked = function () {
        return this.locked;
    };
    /**
     * Returns a boolean indicating if the provided OBDOutput is designated
     * for this Poller instance
     * @return {boolean}
     */
    ECUPoller.prototype.isMatchingPayload = function (data) {
        return data.bytes ?
            data.bytes.substr(2, 2) === this.args.pid.getPid() : false;
    };
    /**
     * Polls the ECU for this specifc ECUPoller's PID. Use this if you want to
     * poll on demand rather than on an interval.
     *
     * This method returns a Promise, but you can also bind a handler for the
     * "data" event if that is preferable.
     */
    ECUPoller.prototype.poll = function () {
        var self = this;
        this.log('poll was called');
        // Cannot call this function if we're already polling
        if (this.polling) {
            return Promise.reject(new Error(self.args.pid.getName() + " - cannot call poll when polling loop is active"));
        }
        return new Promise(function (resolve, reject) {
            var bytesToWrite = self.args.pid.getWriteString();
            self.log("getting connection to poll (" + self.args.pid.getPid() + ")");
            var listener = function (output) {
                self.log('poll received response. removing listener');
                self.unsetTimeoutOperation();
                self.removeOutputListener();
                resolve(output);
            };
            self.setTimeoutOperation(function () {
                reject(new Error("polling timedout"));
            }, 1000);
            self.addOutputListener(listener);
            self.writeBytesToEcu()
                .catch(reject);
        });
    };
    /**
     * Starts this poller polling. This means it will poll at the interval
     * defined in the args, or as close as possible to that
     * @return {void}
     */
    ECUPoller.prototype.startPolling = function () {
        var self = this;
        this.log('start poll interval for %s', this.args.pid.getName());
        if (this.polling) {
            self.log('called startPolling, but it was already started');
            return;
        }
        // Need to lock this component in polling state (TODO: use an FSM pattern)
        this.polling = true;
        // Function we can reuse to do the initial poll should it fail
        function doInitialPoll() {
            self.pollTimer = setTimeout(function () {
                self.log('sending initial poll for polling loop');
                // Handle "data" events when emitted
                self.log('added data listener for poll loop');
                self.addOutputListener(self.onPollLoopData.bind(self));
                // If the initial poll dies not get data quickly enough we need to
                // take action by retrying until it succeeds
                self.setTimeoutOperation(function () {
                    self.log('poll loop failed to get data for initial poll. retrying immediately');
                    doInitialPoll();
                }, 5000);
                self.writeBytesToEcu()
                    .catch(function (e) {
                    self.log('error doing poll loop - ', e.stack);
                    self.log('retrying in 1 second');
                    setTimeout(doInitialPoll, 1000);
                });
            }, 250);
        }
        // Get started!
        doInitialPoll();
    };
    ECUPoller.prototype.removeOutputListener = function () {
        if (this.curListener) {
            this.log('removing "data" listener from parser until new poll is sent');
            parser_1.getParser().removeListener('data', this.curListener);
            this.curListener = undefined;
        }
    };
    ECUPoller.prototype.addOutputListener = function (listener) {
        if (this.curListener) {
            this.log('poller cannot add multiple listeners. removing cur listener');
            this.removeOutputListener();
        }
        this.curListener = listener;
        parser_1.getParser().addListener('data', listener);
    };
    ECUPoller.prototype.writeBytesToEcu = function () {
        var self = this;
        return connection_1.getConnection()
            .then(function (conn) {
            self.msgSendCount++;
            self.lastPollTs = Date.now();
            var bytesToWrite = self.args.pid.getWriteString();
            self.log("got connection. writing data \"" + bytesToWrite + "\"");
            conn.write(bytesToWrite);
        });
    };
    ECUPoller.prototype.setTimeoutOperation = function (fn, ts) {
        var self = this;
        // Clear an existing timeout event
        this.unsetTimeoutOperation();
        self.log("adding new timeout event with delay of " + ts + "ms");
        // If after 2500ms we haven't received data then we need to take an action
        this.timeoutTimer = setTimeout(function () {
            self.log('poll operation timed out. trigger supplied callback');
            fn();
        }, ts);
        // Generate a timeout function. We store it so it can be removed
        this.timeoutFn = function (output) {
            if (self.timeoutTimer && self.isMatchingPayload(output)) {
                self.log('received relevant data event. removing timeout handler');
                self.unsetTimeoutOperation();
            }
        };
        parser_1.getParser().once('data', this.timeoutFn);
    };
    ECUPoller.prototype.unsetTimeoutOperation = function () {
        if (this.timeoutTimer) {
            if (this.timeoutFn) {
                parser_1.getParser().removeListener('data', this.timeoutFn);
            }
            clearTimeout(this.timeoutTimer);
            this.timeoutTimer = undefined;
            this.timeoutFn = undefined;
            this.log('cleared existing poller timeout event');
        }
    };
    /**
     * Called when we receive poller data if this.polling is true
     * @param {OBDOutput} output
     */
    ECUPoller.prototype.onPollLoopData = function (output) {
        var self = this;
        function doNextPoll(time) {
            self.log("queueing next poll for " + time + "ms from now");
            if (self.pollTimer) {
                self.log('doNextPoll called before previous was cleared. possible timeout. clearing');
                clearTimeout(self.pollTimer);
            }
            self.pollTimer = setTimeout(function () {
                if (self.curListener) {
                    self.log("poll timer was triggered, but we are already waiting on data. skipping");
                }
                self.log("poll timer triggered after " + time + "ms");
                self.addOutputListener(self.onPollLoopData.bind(self));
                // Make sure we pay attention to possible timeouts in polling
                // A timeout is triggerd 1 second after the poll time if we get no data
                self.setTimeoutOperation(function () {
                    self.log('timeout 1 sec after requesting data. retrying now');
                    doNextPoll(0);
                }, 1000);
                self.writeBytesToEcu()
                    .catch(function (e) {
                    self.log("error performing next poll. retry in " + time + "ms");
                    doNextPoll(time);
                });
            }, time);
        }
        // If we have no timeoutTimer set then we should not be receiving any data!
        if (self.isMatchingPayload(output)) {
            self.log("poller detected event that matched with self (" + this.args.pid.getPid() + "). payload is " + output.bytes);
            // Clear the timer
            self.pollTimer = undefined;
            // Stay on top of counts
            self.msgRecvCount++;
            // Let folks know we got data
            self.emit('data', output);
            // Track when we got this response
            self.lastResponseTs = Date.now();
            // The emitted event is a match for this poller's PID
            self.log("(" + self.args.pid.getPid() + ") received relevant data event (" + output.bytes + ") " + (Date.now() - self.lastPollTs) + "ms after polling");
            // No longer need to worry about timeouts
            self.unsetTimeoutOperation();
            // Remove ouput listeners. We don't care data unless we requested it
            self.removeOutputListener();
            // Queue next poll
            doNextPoll(self.getNextPollDelay());
        }
        else {
            self.log("detected event (" + output.bytes + ") but it was not a match");
        }
    };
    /**
     * Stops the polling process and cancels any polls about to be queued
     * @return {void}
     */
    ECUPoller.prototype.stopPolling = function () {
        this.log('cacelling poll interval for %s', this.args.pid.getName());
        this.polling = false;
        this.unsetTimeoutOperation();
        if (this.pollTimer) {
            clearTimeout(this.pollTimer);
            this.pollTimer = undefined;
        }
    };
    ;
    return ECUPoller;
}(events_1.EventEmitter));
exports.ECUPoller = ECUPoller;
