/// <reference types="node" />
/// <reference types="bluebird" />
import { EventEmitter } from 'events';
import { PollerArgs, OBDOutput } from './interfaces';
import * as Promise from 'bluebird';
/**
 * Constructor function to create a poller instance.
 *
 * Poller instances will request data from the ECU at a defined refresh rate.
 *
 * @param {Object} opts
 */
export declare class ECUPoller extends EventEmitter {
    private lastResponseTs;
    private lastPollTs;
    private pollTimer?;
    private polling;
    private args;
    private locked;
    private msgSendCount;
    private msgRecvCount;
    private timeoutTimer?;
    private log;
    private timeoutFn?;
    private curListener?;
    constructor(args: PollerArgs);
    /**
     * We want to get as close to the requested refresh rate as possible.
     * This means if the ECU has a response delay then we account for it.
     *
     * @param  {Number} max         The max delay in between pools
     * @param  {Number} lastPollTs  The time we issued the last poll
     * @return {Number}
     */
    private getNextPollDelay();
    /**
     * Locks this poller to prevent it sending any more messages to the ECU
     * @return {void}
     */
    private lock();
    /**
     * Unlocks this poller to allow it to send more messages to the ECU
     * @return {void}
     */
    private unlock();
    /**
     * Returns a boolean, where true indicates this instance is locked
     * @return {boolean}
     */
    private isLocked();
    /**
     * Returns a boolean indicating if the provided OBDOutput is designated
     * for this Poller instance
     * @return {boolean}
     */
    private isMatchingPayload(data);
    /**
     * Polls the ECU for this specifc ECUPoller's PID. Use this if you want to
     * poll on demand rather than on an interval.
     *
     * This method returns a Promise, but you can also bind a handler for the
     * "data" event if that is preferable.
     */
    poll(): Promise<OBDOutput>;
    /**
     * Starts this poller polling. This means it will poll at the interval
     * defined in the args, or as close as possible to that
     * @return {void}
     */
    startPolling(): void;
    private removeOutputListener();
    private addOutputListener(listener);
    private writeBytesToEcu();
    private setTimeoutOperation(fn, ts);
    private unsetTimeoutOperation();
    /**
     * Called when we receive poller data if this.polling is true
     * @param {OBDOutput} output
     */
    private onPollLoopData(output);
    /**
     * Stops the polling process and cancels any polls about to be queued
     * @return {void}
     */
    stopPolling(): void;
}
